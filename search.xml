<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>iterm2 and vim_note</title>
      <link href="/2022/05/07/iterm2%20and%20vim_note/"/>
      <url>/2022/05/07/iterm2%20and%20vim_note/</url>
      
        <content type="html"><![CDATA[<p>权限的切换</p><p>1.普通用户-&gt;root<br>mac打开终端默认是当前登录用户，若要切换到root用户，使用命令：</p><p>第一种：<br>(1) 输入 sudo -i 或者 su - 活着 su - root 然后回车<br>(2) 输入密码，就可以进入root用户<br>(3) 这种方法的终端显示形式为：usernamedeMacBook-Pro:~ root#</p><p>第二种：<br>(1) 输入sudo su然后回车<br>(2) 输入密码，就可以进入root用户<br>(3) 终端显示形式：sh-3.2#</p><p>2.root-&gt;普通用户<br>第一种：从root用户进入你想登陆的普通用户的方法，这里普通用户名用 username 来举例<br>(1) 输入 su - username 然后回车<br>(2) 就可以进入username用户<br>(3) 这种方法的终端显示形式为：usernamedeMacBook-Pro:~ username$</p><p>第二种：<br>(1) 输入su username 然后回车<br>(2) 直接进入username用户<br>(3) 终端显示形式：bash-3.2<br>    vim快捷键<br>gg最前面</p><p>b就是前一个单词的开头 w下一个单词的开头</p><p>GG最后面<br>nyy 复制从光标一下数n行<br>ndd 一样的道理<br>v是选中<br>f什么光标移动最近的什么</p><p>yank all word</p><p>Yaw 复制一个单词</p><p>yy复制整行</p><p>d删除</p><p>u撤销</p><p>:vs垂直切割打开窗口</p><p>:split水平切割打开窗口</p><p>请注意，代替,,;可以用作分隔符。不同的是，在 的情况下from,to，to是相对于当前行的，而在使用时from;to，to是相对于from的地址的！假设您在第 5 行，:1,+1d将删除第 1 行到第 6 行，而:1;+1d只会删除第 1 行和第 2 行。</p><p>该&#x2F;地址可以在另一个地址之前。这允许您堆叠 模式，例如：</p><p>: &#x2F;foo&#x2F;&#x2F;bar&#x2F;&#x2F;quux&#x2F; d<br>这将删除当前行之后包含“foo”的第一行之后包含“bar”的第一行之后包含“quux”的第一行。<br>将’&#x2F;g’或<code>/g</code>放在标记前面以形成动作。</p><p>使用mm记住与标志“M”的当前位置。移动文件，然后通过’m（第一个非空白）或&#96;m（精确列）跳回。退出 Vim 后会记住小写标记，如果你告诉你的 viminfo 文件这样做，请参阅:h viminfo-‘.</p><p>使用mM文件标记“M”来记住当前位置。切换到另一个缓冲区并通过’M或切换回来&#96;M。</p><p>其他动议包括：</p><p>运动跳到..<br>‘[, <code>[先前更改或猛拉的文本的第一行或字符。 &#39;], </code>]先前更改或猛拉的文本的最后一行或字符。<br>‘&lt;, <code>&lt;最后一个视觉选择的起始行或字符。 &#39;&gt;, </code>&gt;最后一个视觉选择的结束行或字符。<br>‘’, &#96;&#96;最近一次跳跃前的位置。<br>‘“, <code>&quot;最后退出当前缓冲区时的位置。 &#39;^, </code>^上次插入停止的位置。<br>‘., <code>.上次更改的位置。 &#39;(, </code>(当前句子的开头。<br>‘), <code>)当前句子的结尾。 &#39;&#123;, </code>{当前段落的开头。<br>‘}, &#96;}当前段落的结尾。<br>也可以在范围内使用标记。您可能之前看到过并想知道它的含义：在可视模式下选择一些文本并执行:，命令行将带有:’&lt;,’&gt;，这意味着以下命令将获得一个表示可视选择的范围。</p><p>使用:marks列出所有标记。阅读中的所有内容:h mark-motions。</p><p>动作、操作符、文本对象<br>动作移动光标。你们都知道h&#x2F; j&#x2F; k&#x2F; l。或w和b。甚至 &#x2F;是一个动作。他们也算一算。2?the<cr>跳转到“the”的倒数第二次出现。</p><p>有关:h navigation所有可用动作，请参阅下面的所有内容。</p><p>运营商作用于文本的区域，例如d，~，gU，&gt;仅举几例。它们在两种情况下使用，正常模式或可视模式。在正常模式下，运算符首先出现，然后是动作，例如&gt;j。在可视模式下，操作员只需对选择进行操作，例如Vjd。</p><p>像动作一样，运算符进行计数，例如2gUw使当前单词的其余部分和下一个单词大写。由于动作和操作符需要计数，所以 2gU2w工作得一样好并且执行gU2w两次。</p><p>查看:h operator所有可用的运算符。使用:set tildeop使~ 充当运营商。</p><p>文本对象作用于周围区域，与作用于一个方向的运动相反。实际上，它们作用于对象，例如整个单词、整个句子、括号之间的所有内容，等等。</p><p>在普通模式下不能使用文本对象来移动光标，因为即使是最熟练的光标也无法同时跳转到两个方向。但是它在可视模式下工作，因为对象的一侧已经被选中，光标只是跳到另一侧。</p><p>文本对象以i(think inner ) 或a(think around ) 开头，后跟一个表示对象的字符。有了i它只能作用在物体本身，与a对象上加上尾随空白。例如diw删除当前单词并ci(更改括号之间的所有内容。</p><p>文本对象进行计数。想象一下((( )))，光标在最内括号上或中间，然后d2a(将删除 2 对内括号和中间的所有内容。</p><p>查看:h text-objects所有可用的文本对象。</p><p>I开头进入输入模式</p><p>A末尾进入输入模式<br>  关机重启命令<br>  shutdown -s 指定时间 在指定时间休眠相当于sleep<br>  reboot     重启    但是shutdown和reboot都得在superroot权限下使用<br>   open命令<br>打开文档使用open命令open 软件名需要到软件绝对地址位置<br>   open -a 使用指定程序打开<br>   -n 是在原软件运行的情况下再打开一个新的软件<br>   brew 命令<br>brew相当于一个app store 下载命令行文件只需要<br>brew install 名字。 下载图形化软件只需要价格cask<br>brew cask install qq 卸载也是一样的uninstall<br>brew search name 联网搜索软件是否存在brew中<br>brew upgrade name 更新软件<br>brea reinstall name 重新安装软件<br>brew info name 查看软件安装地址<br>brew cleanup 清理缓存brew doctor brew故障时使用，查看建议升级</p><p>brew list 查看brew下载的所有软件<br>更改列表、跳转列表<br>最近 100 次更改的位置保存在changelist 中。同一行上的几个小的更改将合并在一起，但位置仍然是最后一个更改的位置（如果您在行中间添加了一些内容）。</p><p>每次跳转时，跳转前的位置都会在jumplist 中记住 。跳转列表最多有 100 个条目。每个窗口都有自己的跳转列表。拆分窗口时，会复制跳转列表。</p><p>跳转是以下命令之一：’, &#96;, G, &#x2F;, ?, n, N, %, (, ), [[, ]], {, }, :s, :tag, L, M,H和开始编辑新文件的命令。</p><p>列表列出所有条目转到旧位置转到较新的位置<br>跳转列表:jumps[count]<c-o>[count]<c-i><br>更改列表:changes[count]g;[count]g,<br>当您列出所有条目时，&gt;将使用一个标记来显示当前位置。通常这将低于位置 1，即最新位置。</p><p>如果您希望在重新启动 Vim 后保留这两个列表，则需要使用 viminfo 文件和:h viminfo-‘.</p><p>注意：最后一次跳转前的位置也保留为一个标记 ，可以跳转到 via&#96;&#96;或’’。</p><p>帮助：</p><p>:h changelist<br>:h jumplist<br>撤销树<br>记住文本状态的最新更改。您可以使用撤消来还原更改并使用重做来重新应用以前还原的更改。</p><p>理解它的重要一点是保存最近更改的数据结构不是 队列而是 树！您的更改是树中的节点，每个（但顶部节点）都有一个父节点。每个节点都保存有关更改的文本和时间的信息。一个分支是一系列节点，从任何一个节点开始，一直到顶部节点。当您撤消更改然后插入其他内容时，会创建新分支。</p><p>ifoo<esc><br>obar<esc><br>obaz<esc><br>u<br>oquux<esc><br>现在你有 3 行，撤销树看起来像这样：</p><pre><code> foo(1)   /bar(2)</code></pre><p>   &#x2F;      <br>baz(3)   quux(4)<br>撤销树有 4 个变化。数字代表创建节点的时间。</p><p>现在有两种方法可以遍历这棵树，我们称它们为branch-wise和 time-wise。</p><p>撤消 ( u) 和重做 ( <c-r>) 以分支方式工作。他们在当前分支上下移动。u将文本状态恢复到节点“bar”之一。另一个u 将进一步将文本状态恢复到节点“foo”之一。现在<c-r> 回到节点“bar”<c-r>的状态，再回到节点“quux”的状态。（再也无法使用分支命令到达节点“baz”了。）</p><p>反对这一点，g-并g+按时工作。因此，g-不会像那样恢复到节点“bar”的状态u，而是恢复到按时间顺序排列的先前状态，节点“baz”。另一个g-将状态恢复为节点“bar”等。因此，g-与g+简单地来回走的时间，分别。</p><p>命令&#x2F;映射行动<br>[count]u, :undo [count]撤消 [count] 次更改。<br>[count]<c-r>, :redo重做 [count] 个更改。<br>U撤消对最新更改行的所有更改。<br>[count]g-, :earlier [count]?转到旧文本状态 [count] 次。这 ”？” 可以是“s”、“m”、“h”、“d”或“f”。例如:earlier 2d从 2 天前转到文本状态。:earlier 1f将进入最新文件保存的状态。<br>[count]g+, :later [count]?同上，但方向不同。<br>撤销树保存在内存中，当 Vim 退出时会丢失。有关如何启用持久撤消的信息，请参阅撤消文件。</p><p>如果您对撤销树感到困惑， undotree在可视化它方面做得很好。</p><p>帮助：</p><p>:h undo.txt<br>:h usr_32</p><p>export HOMEBREW_BOTTLE_DOMAIN&#x3D;’’</p><h3 id="光标控制"><a href="#光标控制" class="headerlink" title="光标控制"></a>光标控制</h3><ul><li>ctrl + a: 到行首</li><li>ctrl + e: 行末</li><li>ctrl + f&#x2F;b: 前进后退，相当于左右方向键，但是显然比移开手按方向键更快</li><li>ctrl + p: 上一条命令，相当于方向键上</li><li>ctrl + r: 搜索命令历史，这个大家都应该很熟悉了</li><li>ctrl + d: 删除当前字符</li><li>ctrl + h: 删除之前的字符</li><li>ctrl + w: 删除光标前的单词</li><li>ctrl + k: 删除到文本末尾</li><li>ctrl + t: 交换光标处文本</li><li>⌘ + —&#x2F;+&#x2F;0: 调整字体大小</li><li>⌘ + r:清屏，其实是滚到新的一屏，并没有清空。ctrl + l 也可以做到。</li></ul><h3 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h3><ul><li>新建窗口：shift + command + d（横向）command + d（竖向）</li><li>关闭窗口：shift + command + w</li><li>前一个窗口：command + &#96;</li><li>后一个窗口：command + ~</li><li>进入窗口 1,2,3：option + command + 编号</li></ul><h3 id="标签页操作"><a href="#标签页操作" class="headerlink" title="标签页操作"></a>标签页操作</h3><ul><li>新建标签页: Command + T</li><li>关闭标签页: Command + W</li><li>前一个标签页: Command + 左方向键，Shift + Command + [</li><li>后一个标签页: Command + 右方向键，Shitf + Command + ]</li><li>进入标签页1，2，3…: Command + 标签页编号<br> *Expose 标签页: Option + Command + E（将标签页打撒到全屏，并可以全局搜索所有的标签页）</li></ul><h3 id="面板操作"><a href="#面板操作" class="headerlink" title="面板操作"></a>面板操作</h3><p>垂直分割: Command + D</p><ul><li>水平分割: Shift + Command + D</li><li>前一个面板: Command + [</li><li>后一个面板: Command + ]</li><li>切换到上&#x2F;下&#x2F;左&#x2F;右面板: Option + Command + 上下左右方向键</li></ul><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><ul><li>支持自定义全局快捷键用于显示和隐藏iTerm2 Preference -&gt; Keys －&gt; Show&#x2F;hide iTerm2 with a system-wide hotkey 打上勾之后</li><li>进入和退出全屏: Command + Enter</li><li>查看当前终端中光标的位置: Command + &#x2F;</li><li>命令自动补全: Command + ;（很少用这个，还是感觉Zsh的补全更好用）</li><li>开启和关闭背景半透明: Command + u</li><li>清屏（重置当前终端）: Command + r</li></ul><h3 id="位置书签"><a href="#位置书签" class="headerlink" title="位置书签"></a>位置书签</h3><p>在当前会话中按Command + Shift + m可以保存当前位置，之后可以按Command + Shift + j跳回这个位置。</p><h3 id="粘贴历史"><a href="#粘贴历史" class="headerlink" title="粘贴历史"></a>粘贴历史</h3><p>使用Command + Shift + h 可以呼出粘贴历史，支持模糊检索。还可以设置将粘贴历史保存在磁盘上（Preferences -&gt; General）</p><h3 id="即时回放"><a href="#即时回放" class="headerlink" title="即时回放"></a>即时回放</h3><p>使用Command + Opt + b 打开即时回放，按Esc退出。即时回放可以记录终端输出的状态，让你“穿越时间”查看终端内容。默认每个会话最多储存4MB的内容，可以在设置中更改（Preferences -&gt; Genernal -&gt; Instant Replay）。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iterm2 and vim_note</title>
      <link href="/2022/05/07/iterm2-and-vim-note/"/>
      <url>/2022/05/07/iterm2-and-vim-note/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/07/hello-world/"/>
      <url>/2022/05/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
